/*
n : 1,000,000 -> 10^6

맨 앞으로 보내거나
맨 뒤로 보내거나

5 2 4 1 3

1 : 1
2 : 23
3:  3
4 : 4
5 : 5

2가 최단.
1 맨앞
4 맨뒤
5 맨뒤 
그렇게 해서 3개

n - 최장 길이

최단 횟수?
bfs느낌이 나긴 하는데?
5는 반드시 맨 오른쪽에 있지 않은 이상 (다른 수가 사라져서 마지막이 되는 방법이 있긴하다, (맨 오른쪽이 1일때), +0 ) 
	23451 -> 12345 이렇게
마지막에 맨 오른쪽으로 보내는게 최단이다. (+1)
	12534 -> 12345 이렇게
음......

연속으로 커지는 수열의 갯수?
가장 긴 연속하는 수열을 고르고, 그 다음, 그 이전수를 맨 오른쪽, 맨 왼쪽으로 둔다.
예를들어 23154 이렇게 있다면, 23이 연속하는 수 중 가장 긴것이다. 그런데 이렇게 

그러니까 문제는 증가하는 걸로 만들고 어차피 이동할건 확실하니까 ㄱㅊ
23 / 1 / 5 / 4
연속하게 함드려면 1을 맨앞으로 두거나, 5를 맨 뒤로 둔다
123/5/4  23/1/45
            12345


연속하지 않은게 있다면 어차피 다른곳으로 바꾸니까.


5 4 6 7 2 3 8 1 9
1부터 시작 : 1
2부터 시작 : 2 3
3부터 시작 : 3
4부터 시작 6 7 8 9
5부터 시작 : 5 6 7 8 9
6부터 시작 : 6 7 8 9
7부터 시작 : 7 8 9
8부터 시작 : 8 9
9부터 시작 : 9

만약 연속하지 않은 다른수들은 그럼 어떻게 해?
예를 들어 2부터 시작 : 2 3 8 9 이거 봤을 때
4를 그럼 어떻게 중간에 넣어야 하지? -> 2,3을 움직이거나 8,9를 움직이지 않는 이상 씹불가
연속으로 증가하는 것
5 4 6 7 2 3 8 1 9
5부터 시작 : 5 6 7 8 9 / 4 맨 앞으로
4 5 6 7 2 3 8 1 9
4부터 시작 : 4 5 6 7 8 9 /  3 맨 앞으로
3 4 5 6 7 2 8 1 9
3부터 시작 : 3 4 5 6 7 8 9 /  2 맨 앞으로
2 3 4 5 6 7 8 1 9
2부터 시작 : 3 4 5 6 7 8 9 /  1 맨 앞으로
1 2 3 4 5 6 7 8 9
완성!
연속하는 수 중 가장 길이가 긴것.


최장 길이를 구하는 알고리즘
1,000,000 = 10^5이다.
1,000,000 의 배열, 그 배열에는 x로 시작하는 연숙 문자열의 길이
check백터를 통해서 그만 할지도 체크
이걸 어떻게 구할까?
모든걸 한번 만 확인.
마지막 수와, 뭔가?
그러면 길이는 N-X를 하면 되니까.
근데 그걸 어떻게 선택하지? 모든 수에 대하여 그걸 추가시켜준다? 왜냐하면 연속하는걸 '찾아서' 체크해야하니까
길이에 대하여 

이건 증가하는게 아니라 문제는 바로 연속해야하니까.


1,000,000 = 10^5이다.

처음부터 끝까지 다 확인한다.
길이 백터를 하나 해야 둬야한다.
또 증가하는 걸 어떻게 알 수 있지?
1 2 3 4 5 6 7 8 9

5 4 6 7 2 3 8 1 9

1 2 3 4 5 6 7 8 9로 시작됨, 갯수인가? 인덱스인가?

0 0 0 0 5 0 0 0 0
0 0 0 4 5 0 0 0 0
0 0 0 4 6 6 0 0 0
0 0 0 4 7 7 7 0 0
0 0 0 4 8 8 8 8 0
1 2 0 4 8 8 8 8 0
1 3 3 4 8 8 8 8 9
1 3 3 4 8 8 8 8 0

수에 연결되어 있는 것 중 가장 최소를 더한다?
합친다?

union set과 같이 합치면?
각각을 더해줄 필요가 없다.
연속하는 수를 발견하면 그에 맞는 인덱스를 찾아서 그냥 거기에 더하면 될거같다.

5 6 7 8 9
5 4 6 7 2 3 8 1 9

1 2 3 4 5 6 7 8 9
8 5 6 2 1 3 4 7 9 // 인덱스 저장
0 0 0 0 0 0 0 0 0 // 갯수 저장

1에 대해서 봤을 땐 2는 더 뒤에 없으니까 그만
2의 입장에서 봤을 땐 3은 뒤에 있으니까 + dfs로 3으로 이동
3의 입장에서는 4는 2니까 종료
4의 입장에서 5는 1이니까 종료
5의 입장에서는 6은 3이니 +, dfs로 6 이동
	6입장에서는 7은 4이니 +, dfs로 7이동
		7입장에선 8이 7이니 +, dfs로 8 이동
			9입장에선 9가 9이니 + 종료
			1
		2
	3
4

*/

#include<iostream>
#include<math.h>
using namespace std;
int input_data[1000001] = {0};
int idx_data[1000001] = {0};
int dp[1000001] = {0};
int n;

int dfs(int num)
{
    if(num == n)
    {
        dp[num] = 1;
        return 1;
    }
    if(dp[num] != 0)
        return dp[num];
    int return_val = 1;
    if(idx_data[num] < idx_data[num + 1])
        return_val += dfs(num + 1);
    dp[num] = return_val;
    return return_val;
}

int main ()
{
    cin >> n;
    for(int i=0; i<n; i++)
        cin >> input_data[i], idx_data[input_data[i]] = i+1;
    for(int i=0; i<n; i++)
        if(dp[i] == 0)
            dfs(i);
    int output = 0;
    for(int i=1; i<=n; i++)
    {
        output = max(output, dp[i]);
    }
    cout << (n - output);
}